<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[LORRIN'S BLOG]]></title>
  <subtitle><![CDATA[Do more,think more]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.lixiaolin.me/"/>
  <updated>2016-01-05T09:42:14.380Z</updated>
  <id>http://www.lixiaolin.me/</id>
  
  <author>
    <name><![CDATA[Lorrin]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MySQL安装和SQL语句入门]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/mysql-install/"/>
    <id>http://www.lixiaolin.me/2016/01/05/mysql-install/</id>
    <published>2016-01-05T08:36:41.000Z</published>
    <updated>2016-01-05T09:42:14.380Z</updated>
    <content type="html"><![CDATA[<p>第一次写博客，正好最近在学习mysql，就由浅入深，先写一遍入门级别的吧：<a id="more"></a></p>
<h2 id="MySQL_u76F8_u5173_u6982_u5FF5"><a href="#MySQL_u76F8_u5173_u6982_u5FF5" class="headerlink" title="MySQL相关概念"></a>MySQL相关概念</h2><p>  MySQL是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 旗下公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。<br>  <img src="http://img.blog.csdn.net/20150707151711159" alt="某班级学生信息"></p>
<p> <strong>表头(head)</strong>:每一列的名称；<br><strong>列(row):</strong> 具有相同数据类型的数据的集合;<br><strong>行(col):</strong> 每一行用来描述某个人/物的具体信息;<br><strong>值(value):</strong> 行的具体信息, 每个值必须与该列的数据类型相同;<br><strong>键(key):</strong> 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性</p>
<h2 id="Windows_u4E0BMySQL_u5B89_u88C5_u548C_u914D_u7F6E"><a href="#Windows_u4E0BMySQL_u5B89_u88C5_u548C_u914D_u7F6E" class="headerlink" title="Windows下MySQL安装和配置"></a>Windows下MySQL安装和配置</h2><p>MYSQL安装有两种方式，第一种是直接下载AppServ组合包（百度下载 <a href="http://rj.baidu.com/soft/detail/15668.html?ald），AppServ" target="_blank" rel="external">http://rj.baidu.com/soft/detail/15668.html?ald），AppServ</a> 是 PHP 网页架站工具组合包，作者将一些网络上免费的架站资源重新包装成单一的安装程序，以方便初学者快速完成架站，AppServ 所包含的软件有：Apache、Apache Monitor、PHP、MySQL、phpMyAdmin等。安装完这个后就能直接使用mysql，并且部署好了web开发的基本环境，可谓一举多得。（安装apperv的时候有一点需要注意，默认安装是会在80端口上装Apache的，注意不要与自己电脑上的端口冲突了，可以手动修改使用的端口，改成比如8080）。<br>第二种就是直接下载<a href="http://www.mysql.com/downloads/" target="_blank" rel="external">mysql</a>的安装包，安装过程中基本全部点下一步就好，值得一提的是在到了编码选择的时候选择”utf8”。安装完Mysql后还需装一下<a href="http://www.navicat.com.cn/download" target="_blank" rel="external">Navicat</a>，navicat是一个可视化的数据库管理工具，下载后可以连接自己的mysql数据库，方便操作。<br><strong>不管哪种安装方式，有一点请注意：牢记自己在mysql安装过程中输入的root的密码，后面会用到。</strong></p>
<p><img src="http://img.blog.csdn.net/20150709113803555" alt="这里写图片描述"></p>
<p>如上图，安装完navicat之后打开点击左上角的连接，连接名不需要填，在密码栏里输入安装mysql时设置的密码<br>到这里为止，mysql的安装基本就结束了.</p>
<p><strong>MySQL服务的启动、停止与卸载</strong><br>在 Windows 命令提示符下运行:<br>启动: net start MySQL<br>停止: net stop MySQL<br>卸载: sc delete MySQL</p>
<h3 id="MySQL_u7684_u57FA_u672C_u6570_u636E_u7C7B_u578B"><a href="#MySQL_u7684_u57FA_u672C_u6570_u636E_u7C7B_u578B" class="headerlink" title="MySQL的基本数据类型"></a>MySQL的基本数据类型</h3><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:right">大小</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">char[length]</td>
<td style="text-align:right">length字节</td>
<td style="text-align:center">定长字段，长度为0-255个字节</td>
</tr>
<tr>
<td style="text-align:left">varchar[length]</td>
<td style="text-align:right">string长度+1字节</td>
<td style="text-align:center">变长字段，在mysql5.03以前，长度为0-255个字节，在5.0.3以后，最大长度为65535字节。一个utf8字符占3个字节、一个gbk字符占两个字节。</td>
</tr>
<tr>
<td style="text-align:left">tinytext</td>
<td style="text-align:right">string长度+1字节</td>
<td style="text-align:center">字符串，长度为0-255个字节</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td style="text-align:right">string长度+2字节</td>
<td style="text-align:center">字符串，最大长度为0-65535个字节</td>
</tr>
<tr>
<td style="text-align:left">mediumtext</td>
<td style="text-align:right">string长度+3字节</td>
<td style="text-align:center">字符串，组嗲长度为16777215个字节</td>
</tr>
<tr>
<td style="text-align:left">longtext</td>
<td style="text-align:right">string长度+4字节</td>
<td style="text-align:center">字符串，最大长度为4194967295个字节</td>
</tr>
<tr>
<td style="text-align:left">tinyint[length]</td>
<td style="text-align:right">1字节</td>
<td style="text-align:center">范围:-128~127或0~255</td>
</tr>
<tr>
<td style="text-align:left">smallint[length]</td>
<td style="text-align:right">2字节</td>
</tr>
<tr>
<td style="text-align:left">mediumint[length]  3字节</td>
</tr>
<tr>
<td style="text-align:left">int[length]</td>
<td style="text-align:right">4字节</td>
</tr>
<tr>
<td style="text-align:left">bigint[length]</td>
<td style="text-align:right">8字节</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:right">4字节</td>
</tr>
<tr>
<td style="text-align:left">double[length,decimals]</td>
<td style="text-align:right">8字节</td>
<td style="text-align:center">运行固定的小数点</td>
</tr>
<tr>
<td style="text-align:left">decimal[length,decimals]</td>
<td style="text-align:right">length+1字节或length+2字节</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:right">3字节</td>
<td style="text-align:center">采用YYYY-MM-DD格式</td>
</tr>
<tr>
<td style="text-align:left">datetime</td>
<td style="text-align:right">8字节</td>
<td style="text-align:center">采用YYYY-MM-DD HH:mm:SS格式</td>
</tr>
<tr>
<td style="text-align:left">timestamp</td>
<td style="text-align:right">4字节</td>
<td style="text-align:center">采用YYYYMMDDHHmmSS格式</td>
</tr>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:right">3字节</td>
<td style="text-align:center">采用HH:MM:SS格式</td>
</tr>
<tr>
<td style="text-align:left">enum v1或2字节</td>
<td style="text-align:right">枚举类型</td>
</tr>
<tr>
<td style="text-align:left">set</td>
<td style="text-align:right">1、2、3、4或8字节</td>
<td style="text-align:center">与enum一样，只不过每一列可以具有多个可能的值</td>
</tr>
<tr>
<td style="text-align:left">blob</td>
<td style="text-align:right">是text的一个变体。</td>
<td style="text-align:center">允许存储二进制文件，还可用于某些加密数据。</td>
</tr>
</tbody>
</table>
<h2 id="u5E38_u7528SQL_u8BED_u53E5"><a href="#u5E38_u7528SQL_u8BED_u53E5" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="u4E00_u3001_u6570_u636E_u5E93_u521B_u5EFA"><a href="#u4E00_u3001_u6570_u636E_u5E93_u521B_u5EFA" class="headerlink" title="一、数据库创建"></a>一、数据库创建</h3><p>1.创建数据库<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [<span class="keyword">if</span> <span class="keyword">not</span> exists] db_name [character <span class="keyword">set</span> xxx] [collate xxx]</span><br><span class="line">*创建一个名称为mydb1的数据库。</span><br><span class="line">  <span class="keyword">create</span> database mydb1;</span><br><span class="line">*创建一个使用utf8字符集的mydb2数据库。</span><br><span class="line">  <span class="keyword">create</span> database mydb2 character <span class="keyword">set</span> utf8;</span><br><span class="line">*创建一个使用utf8字符集，并带校对规则的mydb3数据库。</span><br><span class="line">  <span class="keyword">create</span> database mydb3 character <span class="keyword">set</span> utf8 collate utf8_bin ;</span><br></pre></td></tr></table></figure></p>
<p>2.查看数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">show</span> <span class="keyword">databases</span>;</span>查看所有数据库</span><br><span class="line"><span class="operator"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db_name;</span> 查看数据库的创建方式</span><br></pre></td></tr></table></figure></p>
<p>3.修改数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">alter</span> <span class="keyword">database</span> db_name [<span class="built_in">character</span> <span class="keyword">set</span> xxx] [<span class="keyword">collate</span> xxxx]</span></span><br></pre></td></tr></table></figure></p>
<p>4.删除数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">drop</span> <span class="keyword">database</span> [<span class="keyword">if</span> <span class="keyword">exists</span>] db_name;</span></span><br></pre></td></tr></table></figure></p>
<p>5.使用数据库<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">切换数据库 <span class="operator"><span class="keyword">use</span> db_name;</span></span><br><span class="line">查看当前使用的数据库 <span class="operator"><span class="keyword">select</span> <span class="keyword">database</span>();</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u4E8C_u3001_u8868"><a href="#u4E8C_u3001_u8868" class="headerlink" title="二、表"></a>二、表</h3><p>1、创建表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> tab_name(</span><br><span class="line">  field1 <span class="keyword">type</span>,</span><br><span class="line">  field2 <span class="keyword">type</span>,</span><br><span class="line">  ...</span><br><span class="line">  fieldn <span class="keyword">type</span></span><br><span class="line"> *创建一个员工表employee</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment ,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="built_in">bit</span> <span class="keyword">default</span> <span class="number">1</span>,</span><br><span class="line">    birthday <span class="built_in">date</span>,</span><br><span class="line">    entry_date <span class="built_in">date</span>,</span><br><span class="line">    job <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="keyword">double</span>,</span><br><span class="line">    <span class="keyword">resume</span> <span class="built_in">text</span></span><br><span class="line">  );</span></span><br></pre></td></tr></table></figure></p>
<p>2、查看表信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc tab_name 查看表结构</span><br><span class="line"><span class="operator"><span class="keyword">show</span> <span class="keyword">tables</span> 查看当前数据库中的所有的表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tab_name  查看当前数据库表建表语句</span></span><br></pre></td></tr></table></figure></p>
<p>3、修改表结构<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(1)增加一列</span><br><span class="line">  <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> tab_name <span class="keyword">add</span> [<span class="keyword">column</span>] 列名 类型;</span></span><br><span class="line">(2)修改一列类型</span><br><span class="line">  <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> tab_name <span class="keyword">modify</span> 列名 类型;</span></span><br><span class="line">(3)修改列名</span><br><span class="line">  <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> tab_name <span class="keyword">change</span> [<span class="keyword">column</span>] 列名 新列名 类型;</span></span><br><span class="line">(4)删除一列</span><br><span class="line">  <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> tab_name <span class="keyword">drop</span> [<span class="keyword">column</span>] 列名;</span></span><br><span class="line">(5)修改表名</span><br><span class="line">  <span class="operator"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span></span><br><span class="line">(6)修该表所用的字符集</span><br><span class="line">  <span class="operator"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="built_in">character</span> <span class="keyword">set</span> utf8;</span></span><br></pre></td></tr></table></figure></p>
<p>4、删除表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">drop</span> <span class="keyword">table</span> tab_name;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u4E09_u3001_u8868_u8BB0_u5F55"><a href="#u4E09_u3001_u8868_u8BB0_u5F55" class="headerlink" title="三、表记录"></a>三、表记录</h3><p>  1、增加一条记录insert<br>  插入的数据应与字段的数据类型相同。<br>  数据的大小应在列的规定范围内，例如：不能将一个长度为80的字符串加入到长度为40的列中。<br>  在values中列出的数据位置必须与被加入的列的排列位置相对应。<br>  字符和日期型数据应包含在单引号中’zhang’ ‘2013-04-20’<br>  插入空值：不指定某列的值或insert into table value(null)，则该列取空值。<br>  如果要插入所有字段可以省写列列表，直接按表中字段顺序写值列表insert into tab_name values(value1,value2,……);<br>  比如：使用insert语句向表中插入三个员工的信息。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> tab_name (field1,filed2,.......) <span class="keyword">values</span> (value1,value2,.......);</span></span><br><span class="line"><span class="operator"><span class="keyword">insert</span> <span class="keyword">into</span> emp (<span class="keyword">name</span>,birthday,entry_date,job,salary) <span class="keyword">values</span> (<span class="string">'张飞'</span>,<span class="string">'1990-09-09'</span>,<span class="string">'2000-01-01'</span>,<span class="string">'打手'</span>,<span class="number">999</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>  2、修改表记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">update</span> tab_name <span class="keyword">set</span> field1=value1,field2=value2,......[<span class="keyword">where</span> 语句]</span><br><span class="line">将姓名为’ls’的员工薪水修改为<span class="number">4000</span>元,job改为ccc。</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> salary=<span class="number">4000</span>,job=<span class="string">'ccc'</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zs'</span></span></span><br></pre></td></tr></table></figure></p>
<p>  3、删除表操作<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tab_name [<span class="built_in">where</span> ....]</span><br></pre></td></tr></table></figure></p>
<p>  如果不跟where语句则删除整张表中的数据<br>  delete只能用来删除一行记录，不能值删除一行记录中的某一列值（这是update操作）。<br>  <strong>*delete语句只能删除表中的内容，不能删除表本身，想要删除表，用drop</strong><br>  同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应该始终不要忘记这个潜在的问题。<br>  <strong>*TRUNCATE TABLE也可以删除表中的所有数据，词语句首先摧毁表，再新建表。此种方式删除的数据不能在事务中恢复。</strong><br>  删除表中名称为’zs’的记录。<br>  delete from emp where name=’黄忠’;<br>  删除表中所有记录。<br>  delete from emp;<br>  使用truncate删除表中记录。<br>  truncate table emp;<br>  <strong>所以如果需要删除整张表的数据，如果记录很多，那么使用TRUNCATE删除将会有比较高的效率</strong></p>
<p>   4、select操作<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">select [<span class="keyword">distinct</span>] *|field1，field2，......   <span class="keyword">from</span> tab_name</span><br><span class="line">其中<span class="keyword">from</span>指定从哪张表筛选，*表示查找所有列，也可以指定一个列列表明确指定要查找的列，<span class="keyword">distinct</span>用来剔除重复行。</span><br><span class="line">查询表中所有学生的信息</span><br><span class="line"></span><br><span class="line">select * <span class="keyword">from</span> exam;</span><br><span class="line">查询表中所有学生的姓名和对应的英语成绩。</span><br><span class="line">select name,english <span class="keyword">from</span> exam;</span><br><span class="line">过滤表中重复数据。</span><br><span class="line">select <span class="keyword">distinct</span> english <span class="keyword">from</span> exam;</span><br><span class="line"><span class="keyword">distinct</span> 对于查询时去掉重复的记录特别有效</span><br><span class="line">select 也可以使用表达式，并且可以使用 <span class="keyword">as</span> 别名</span><br><span class="line">在所有学生分数上加<span class="number">10</span>分特长分显示。</span><br><span class="line">select name,english+<span class="number">10</span>,chinese+<span class="number">10</span>,math+<span class="number">10</span> <span class="keyword">from</span> exam;</span><br><span class="line">统计每个学生的总分。</span><br><span class="line">select name,english+chinese+math <span class="keyword">from</span> exam;</span><br><span class="line">使用别名表示学生总分。</span><br><span class="line">select name,english+chinese+math <span class="keyword">as</span> 总成绩 <span class="keyword">from</span> exam;</span><br><span class="line">select name,english+chinese+math 总成绩 <span class="keyword">from</span> exam;</span><br><span class="line">select name english <span class="keyword">from</span> exam;</span><br><span class="line">使用where子句，进行过滤查询</span><br><span class="line">查询姓名为<span class="type">XXX</span>的学生成绩</span><br><span class="line">select * <span class="keyword">from</span> exam where name='张飞';</span><br><span class="line">查询英语成绩大于<span class="number">90</span>分的同学</span><br><span class="line">select name,english <span class="keyword">from</span> exam where english&gt;<span class="number">90</span>;</span><br><span class="line">查询总分大于<span class="number">200</span>分的所有同学</span><br><span class="line">select name,math+english+chinese <span class="keyword">as</span> 总成绩 <span class="keyword">from</span> exam where math+english+chinese&gt;<span class="number">200</span> ;</span><br><span class="line">where字句中可以使用：</span><br><span class="line">        比较运算符：</span><br><span class="line">              &gt; &lt; &gt;= &lt;= &lt;&gt;</span><br><span class="line">              between <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> 值在<span class="number">10</span>到<span class="number">20</span>之间</span><br><span class="line">              <span class="keyword">in</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">3</span>)值是<span class="number">10</span>或<span class="number">20</span>或<span class="number">30</span></span><br><span class="line">              like '张pattern' pattern可以是%或者_，如果是%则表示任意多字符，</span><br><span class="line"></span><br><span class="line">*逻辑运算符</span><br><span class="line">                                 在多个条件直接可以使用逻辑运算符 <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line"></span><br><span class="line">查询英语分数在 <span class="number">80</span>－<span class="number">100</span>之间的同学。</span><br><span class="line">select name ,english <span class="keyword">from</span> exam where english between <span class="number">80</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line">查询数学分数为<span class="number">75</span>,<span class="number">76</span>,<span class="number">77</span>的同学。</span><br><span class="line">select name ,math <span class="keyword">from</span> exam where math <span class="keyword">in</span> (<span class="number">75</span>,<span class="number">76</span>,<span class="number">77</span>);</span><br><span class="line">查询所有姓张的学生成绩。</span><br><span class="line">select * <span class="keyword">from</span> exam where name like '张%';</span><br><span class="line">查询数学分&gt;<span class="number">70</span>，语文分&gt;<span class="number">80</span>的同学。</span><br><span class="line">select name <span class="keyword">from</span> exam where math&gt;<span class="number">70</span> <span class="keyword">and</span> chinese &gt;<span class="number">80</span>;</span><br><span class="line">查找缺考数学的学生的姓名</span><br><span class="line">select name <span class="keyword">from</span> exam where math <span class="keyword">is</span> null;</span><br></pre></td></tr></table></figure></p>
<p><strong>Order by 指定排序的列，排序的列即可是表中的列名，也可以是select 语句后指定的别名。</strong><br>Asc 升序、Desc 降序，其中asc为默认值<br>ORDER BY 子句应位于SELECT语句的结尾。<br>对数学成绩排序后输出。<br><figure class="highlight"><figcaption><span>* from exam order by math;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#23545;&#24635;&#20998;&#25490;&#24207;&#25353;&#20174;&#39640;&#21040;&#20302;&#30340;&#39034;&#24207;&#36755;&#20986;&#10;```select name ,(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) &#24635;&#25104;&#32489; from exam order by &#24635;&#25104;&#32489; desc;</span><br></pre></td></tr></table></figure></p>
<p>对姓张的学生成绩排序输出<br><code>select name ,(ifnull(math,0)+ifnull(chinese,0)+ifnull(english,0)) 总成绩 from exam where name like &#39;张%&#39; order by 总成绩 desc;</code><br>  <strong>注意：这里使用了ifnull()函数，ifnull(math,0)表示如果math为null的话就用0代替math</strong><br>    今天先写到这里，关于聚合函数等等的一些操作过两天有空再写~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一次写博客，正好最近在学习mysql，就由浅入深，先写一遍入门级别的吧：]]>
    
    </summary>
    
      <category term="MYSQL" scheme="http://www.lixiaolin.me/tags/MYSQL/"/>
    
      <category term="SQL" scheme="http://www.lixiaolin.me/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查询选修全部课程的学生姓名和所属单位]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/sql-query-all/"/>
    <id>http://www.lixiaolin.me/2016/01/05/sql-query-all/</id>
    <published>2016-01-05T08:35:43.000Z</published>
    <updated>2016-01-05T08:41:05.910Z</updated>
    <content type="html"><![CDATA[<p>#####查询选修全部课程的学生姓名和所属单位<br>在解答这个问题之前先举一个小例子，现有3张表<br>S (SI,SN,SD,SA)   SI,SN,SD,SA 分别代表学号、学员姓名、所属单位、学员年龄<br>C (CI,CN )     CI,CN 分别代表课程编号、课程名称<br>SC ( SI,CI,G )   SI,CI,G 分别代表学号、所选修的课程编号、学习成绩<br><a id="more"></a><br>查看SC表中的全部信息如下：</p>
<p><img src="http://img.blog.csdn.net/20150709225419125" alt="这里写图片描述"><br> 要求返回每个SC表中每个学生选修的课数<br>执行如下语句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  <span class="keyword">sc</span>.SI 学号,</span><br><span class="line">  <span class="keyword">COUNT</span>(<span class="keyword">sc</span>.<span class="keyword">CI</span>) 选课门数</span><br><span class="line">FROM</span><br><span class="line">  <span class="keyword">sc</span>,c</span><br><span class="line">GROUP <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">sc</span>.SI</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="http://img.blog.csdn.net/20150709230542010" alt="这里写图片描述"></p>
<p>执行如下语句：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  <span class="keyword">sc</span>.SI 学号,</span><br><span class="line">  <span class="keyword">COUNT</span>(<span class="keyword">sc</span>.<span class="keyword">CI</span>) 选课门数</span><br><span class="line">FROM</span><br><span class="line">  <span class="keyword">sc</span></span><br><span class="line">GROUP <span class="keyword">BY</span></span><br><span class="line">  <span class="keyword">sc</span>.SI</span><br></pre></td></tr></table></figure>
<p> 执行结果如下：<br> <img src="http://img.blog.csdn.net/20150709230604740" alt="这里写图片描述"></p>
<p>相信看到这里应该知道我要说的是什么问题了，可以看到<strong>两次查询语句的唯一差别就是 from sc和from sc,c</strong>，然而结果却相差很多，这个就是由于关联查询造成的，从sc、c两张表中选择时结果会存在很多重复的行，所以需要剔除重复的行，因此在查询时如果涉及到多张表，使用group by分组获取数据时一定要记得剔除重复数据。<br><strong>下面解决第一个问题</strong><br>使用标准SQL嵌套语句查询选修全部课程的学员姓名和所属单位<br>解决方法1：</p>
<p>先在sc表中按学号分组找出选修所有课程的学生的学号，然后在S中通过SI去取学员学号和所属单位<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span></span><br><span class="line">  s.SN 姓名,</span><br><span class="line">  s.SD 单位</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  s.SI <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      sc.SI</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      sc,</span><br><span class="line">      <span class="keyword">c</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      sc.SI</span><br><span class="line">    <span class="keyword">HAVING</span></span><br><span class="line">      <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> sc.CI) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> <span class="keyword">c</span>)</span><br><span class="line">  )</span></span><br></pre></td></tr></table></figure></p>
<p>解决方法二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span></span><br><span class="line">  s.SI,</span><br><span class="line">  s.SD</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      *</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      <span class="keyword">c</span></span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">          *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">          sc</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">          CI = s.SI</span><br><span class="line">        <span class="keyword">AND</span> CI = <span class="keyword">c</span>.CI</span><br><span class="line">      )</span><br><span class="line">  )</span></span><br></pre></td></tr></table></figure>
<p><strong>两种方法相比，第一种更加灵活易懂，更加考验了使用SQL查询的能力，但是要记得剔除重复数据</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#####查询选修全部课程的学生姓名和所属单位<br>在解答这个问题之前先举一个小例子，现有3张表<br>S (SI,SN,SD,SA)   SI,SN,SD,SA 分别代表学号、学员姓名、所属单位、学员年龄<br>C (CI,CN )     CI,CN 分别代表课程编号、课程名称<br>SC ( SI,CI,G )   SI,CI,G 分别代表学号、所选修的课程编号、学习成绩<br>]]>
    
    </summary>
    
      <category term="SQL" scheme="http://www.lixiaolin.me/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Oracle中序列的使用]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/oracle-sequence/"/>
    <id>http://www.lixiaolin.me/2016/01/05/oracle-sequence/</id>
    <published>2016-01-05T08:33:53.000Z</published>
    <updated>2016-01-05T08:34:57.765Z</updated>
    <content type="html"><![CDATA[<p>oracle中序列可以自动产生递增或者递减的序列，数据库中表的唯一主键ID一般都是序列产生的。<br><a id="more"></a><br>sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Create sequence</span></span><br><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">sequence</span> SEQ_E_PRICE</span><br><span class="line"><span class="keyword">minvalue</span> <span class="number">1</span></span><br><span class="line">maxvalue <span class="number">9999999999999999999999999999</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">cache</span> <span class="number">100</span>;</span></span><br></pre></td></tr></table></figure>
<p>SEQ_E_PRICE是自定义的序列的名字<br>minvalue和maxvalue分别是序列增长的最大值与最小值<br>start with是序列增长的开始值，这里是从1开始增长<br>increment by 是增长的步长，可以设为1，2，3等等，按自己的需求来就行<br>cache 100指Oracle序列允许将序列提前生成 cache 100个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中（即cache）去得到序列，这样就能避免大量语句发生请求来申请序列时造成的性能瓶颈问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>oracle中序列可以自动产生递增或者递减的序列，数据库中表的唯一主键ID一般都是序列产生的。<br>]]>
    
    </summary>
    
      <category term="ORACLE" scheme="http://www.lixiaolin.me/tags/ORACLE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java和js中小数和百分数的互相转换]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/decimal-percent-change/"/>
    <id>http://www.lixiaolin.me/2016/01/05/decimal-percent-change/</id>
    <published>2016-01-05T08:32:14.000Z</published>
    <updated>2016-01-05T08:46:07.307Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E00_u3001_u767E_u5206_u6570_u8F6C_u5C0F_u6570"><a href="#u4E00_u3001_u767E_u5206_u6570_u8F6C_u5C0F_u6570" class="headerlink" title="一、百分数转小数"></a>一、百分数转小数</h2><p>   Java中：<a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">changePercentToPoint</span><span class="params">(String percent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Float(percent.substring(<span class="number">0</span>, percent.indexOf(<span class="string">"%"</span>))) / <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>js中：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPoint</span><span class="params">(percent)</span>&#123;</span></span><br><span class="line">    var <span class="built_in">str</span>=percent.replace(<span class="string">"%"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">str</span>= <span class="built_in">str</span>/<span class="number">100</span>;</span><br><span class="line">    return <span class="built_in">str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u4E8C_u3001_u5C0F_u6570_u8F6C_u767E_u5206_u6570"><a href="#u4E8C_u3001_u5C0F_u6570_u8F6C_u767E_u5206_u6570" class="headerlink" title="二、小数转百分数"></a>二、小数转百分数</h2><p>Java中<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">String</span> changePointToPercent(<span class="built_in">float</span> <span class="built_in">point</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">String</span>.valueOf(<span class="built_in">point</span>*<span class="number">100</span>)+<span class="string">"%"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>js中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">*这里需要先用Number进行数据类型转换，然后去指定截取转换后的小数点后几位(按照四舍五入)，这里是截取一位，0.1266转换后会变成12.7%</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPercent</span>(<span class="params">point</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str=<span class="built_in">Number</span>(point*<span class="number">100</span>).toFixed(<span class="number">1</span>);</span><br><span class="line">    str+=<span class="string">"%"</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E00_u3001_u767E_u5206_u6570_u8F6C_u5C0F_u6570"><a href="#u4E00_u3001_u767E_u5206_u6570_u8F6C_u5C0F_u6570" class="headerlink" title="一、百分数转小数"></a>一、百分数转小数</h2><p>   Java中：]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sublime Text2 配置tab为4个空格]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/sublimetext-setting/"/>
    <id>http://www.lixiaolin.me/2016/01/05/sublimetext-setting/</id>
    <published>2016-01-05T08:29:07.000Z</published>
    <updated>2016-01-05T08:42:18.064Z</updated>
    <content type="html"><![CDATA[<p>在顶部菜单栏找到<br>Preference-&gt;Settings-defalut:<br><a id="more"></a><br>添加这两行：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The number <span class="keyword">of</span> spaces a tab is considered equal <span class="keyword">to</span></span><br><span class="line">    <span class="string">"tab_size"</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">// Set <span class="keyword">to</span> <span class="literal">true</span> <span class="keyword">to</span> <span class="keyword">insert</span> spaces <span class="keyword">when</span> tab is pressed</span><br><span class="line">    <span class="string">"translate_tabs_to_spaces"</span>: <span class="literal">true</span>,</span><br></pre></td></tr></table></figure>
<p>如果报错的话，那就是本来的配置文件中已经设置过了，使用ctrl+F定位到对应位置，将”translate_tabs_to_spaces”: false 改成 true即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在顶部菜单栏找到<br>Preference-&gt;Settings-defalut:<br>]]>
    
    </summary>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
      <category term="Sublimetext" scheme="http://www.lixiaolin.me/tags/Sublimetext/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python中range函数的使用.]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/python-func-range/"/>
    <id>http://www.lixiaolin.me/2016/01/05/python-func-range/</id>
    <published>2016-01-05T08:27:42.000Z</published>
    <updated>2016-01-05T08:28:24.637Z</updated>
    <content type="html"><![CDATA[<p>range()函数，用来产生整数序列，可以指定步长，这样就能很方便了。<br><a id="more"></a><br>参数说明：<br>range(start， end， scan):<br>start：计数从start开始，默认为0，range(2)=range(0,2)<br>end： 计数到end结束  list(range(2))为[0,1]  注意包左不包右！<br>scan:  计数的步长，默认为1，可以指定   比如range(0,4,2)</p>
<p>加入现在需要构造一个1, 3, 5, 7, …, 99的列表，可以通过循环实现</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">L</span> = []</span><br><span class="line"><span class="keyword">n</span> = 1</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">n</span> &lt;= 99:</span><br><span class="line">    <span class="keyword">L</span>.<span class="keyword">append</span>(<span class="keyword">n</span>)</span><br><span class="line">    <span class="keyword">n</span> = <span class="keyword">n</span> + 2</span><br></pre></td></tr></table></figure>
<p>当采用range就一行代码可以搞定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#奇数序列</span></span><br><span class="line"><span class="built_in">list</span>(range(<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>))</span><br><span class="line"><span class="preprocessor">#偶数序列</span></span><br><span class="line"><span class="built_in">list</span>(range(<span class="number">0</span>,<span class="number">100</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>range()函数，用来产生整数序列，可以指定步长，这样就能很方便了。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.lixiaolin.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解Java中格式化输出浮点数]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/java-format-float/"/>
    <id>http://www.lixiaolin.me/2016/01/05/java-format-float/</id>
    <published>2016-01-05T08:26:10.000Z</published>
    <updated>2016-01-05T08:51:41.090Z</updated>
    <content type="html"><![CDATA[<p>在Java中，我们经常使用%f来格式化输出浮点数，最近发现一个有趣的事。%f可以指定输出字符的宽度和小数点后的位数。<br><a id="more"></a><br>1、只指定了整个输出的宽度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x=<span class="number">0.123456789</span>;</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%10f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%9f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%8f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%7f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%4f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是这样的<br><img src="http://img.blog.csdn.net/20150829202208567" alt="这里写图片描述"><br>可以看到，5条记录的小数点后的位数都是6位，也就是说在不指定小数点后位数的前提下，输出都是默认的6位<br>那么问题来了，%7f 的结果为什么是这样的呢？<br>7指定输出的宽度是7个字符，但是显然，6位的默认小数+小数点+0  所以总共占了8位，7&lt;8，所以这里的7设置无效，jvm采用默认输出，可以看到，只要指定的长度小于8都是无效的，都会采用默认输出。<br>如果长度大于8的话，那么就输出指定的位数，那么前面的空格是怎么算的呢？10%f 代表总共为10，还是刚才的算法，10-固定的6位小数-小数点-0=2  所以前面输出两个空格。</p>
<p>2、指定输出的宽度，又指定了小数点后的宽度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x=<span class="number">0.123456789</span>;</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%8.3f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%4.3f"</span>,x);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.<span class="built_in">printf</span>(<span class="string">"%4.12f"</span>,x);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是这样的<br><img src="http://img.blog.csdn.net/20150829203159883" alt="这里写图片描述"><br>输出先满足小数点后长度的要求<br>如果总长度-2&gt;=小数点后长度，那么总长度设置有效，输出总长度就是设置的总长度，如 %8.3f<br>如果总长度-2&lt;小数点后长度，那么总长度设置无效，输出总长度为小数点后长度+2  并且左对齐输出，如%4.12f</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Java中，我们经常使用%f来格式化输出浮点数，最近发现一个有趣的事。%f可以指定输出字符的宽度和小数点后的位数。<br>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ServletConfig和ServletContext的区别]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/servletcontext-servletconfig-diff/"/>
    <id>http://www.lixiaolin.me/2016/01/05/servletcontext-servletconfig-diff/</id>
    <published>2016-01-05T08:22:31.000Z</published>
    <updated>2016-01-05T11:13:40.848Z</updated>
    <content type="html"><![CDATA[<p>1、ServletConfig<br>    ServletConfig是针对于当前Servlet的，其他servlet访问不到这个servlet的信息。一个servlet的ServletConfig对象不能被另一个servlet访问。<br>    ServletConfig常用来获取当前Servlet的配置信息<br>    ServletConfig中还维护了一个对ServletContext的引用<br><a id="more"></a><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">配置如下：</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;description&gt;This <span class="keyword">is</span> <span class="keyword">the</span> description <span class="keyword">of</span> <span class="keyword">my</span> J2EE component&lt;/description&gt;</span><br><span class="line">    &lt;display-<span class="property">name</span>&gt;This <span class="keyword">is</span> <span class="keyword">the</span> display <span class="property">name</span> <span class="keyword">of</span> <span class="keyword">my</span> J2EE component&lt;/display-<span class="property">name</span>&gt;</span><br><span class="line">    &lt;servlet-<span class="property">name</span>&gt;ServletConfigTest&lt;/servlet-<span class="property">name</span>&gt;</span><br><span class="line">    &lt;servlet-<span class="type">class</span>&gt;com.lxl.servlet.ServletConfigTest&lt;/servlet-<span class="type">class</span>&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">      &lt;param-<span class="property">name</span>&gt;<span class="property">name</span>&lt;/param-<span class="property">name</span>&gt;</span><br><span class="line">      &lt;param-value&gt;value&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">       &lt;param-<span class="property">name</span>&gt;password&lt;/param-<span class="property">name</span>&gt;</span><br><span class="line">       &lt;param-value&gt;<span class="number">791341891</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">Servlet1中获取当前servlet的配置信息:</span><br><span class="line">Enumeration&lt;String&gt; enu=this.getServletConfig().getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span>(enu.hasMoreElements())&#123;</span><br><span class="line">      String <span class="property">name</span>=enu.nextElement();</span><br><span class="line">      String value=config.getInitParameter(<span class="property">name</span>);</span><br><span class="line">      response.getWriter().<span class="command">write</span>(<span class="string">"&lt;br&gt;name:"</span>+<span class="property">name</span>+<span class="string">" value:"</span>+value+<span class="string">"&lt;/br&gt;"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、ServletContext<br>     ServletContext是针对于整个web应用的，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。是四大域对象的一种<br>     常用来在servelt间通信。<br>     利用其进行通信的时候，这里有一点需要注意，获取ServletContext必须通过ServletConfig来获取，不能这样获取：this.getServletContext()</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存值：</span><br><span class="line">int price=<span class="number">198</span>;</span><br><span class="line"><span class="keyword">this</span>.getServletConfig().getServletContext().setAttribute(<span class="string">"price"</span>, price);</span><br><span class="line">取值：     response.getWriter().write(String.valueOf(<span class="keyword">this</span>.getServletConfig().getServletContext().getAttribute(<span class="string">"price"</span>)));</span><br><span class="line"><span class="regexp">//</span>注意存和取都不能用<span class="keyword">this</span>.getServletContext().setAttribute(<span class="string">"price"</span>, price);不然会为<span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>那么按理说ServletContext对象的作用域比ServletConfig作用域大，为什么要从ServletConfig中到得<br>ServletContext对象呢？可以这样理解，在tomcate这个web容器里面保存了很多ServletContext，请求容器时到底把哪一个给你呢，那么就应该把包含了当前ServletConfig的那个容器给你，就是说取ServletConfig对象的父级对象</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、ServletConfig<br>    ServletConfig是针对于当前Servlet的，其他servlet访问不到这个servlet的信息。一个servlet的ServletConfig对象不能被另一个servlet访问。<br>    ServletConfig常用来获取当前Servlet的配置信息<br>    ServletConfig中还维护了一个对ServletContext的引用<br>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="Servlet" scheme="http://www.lixiaolin.me/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决properties文件乱码问题]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/properties-coding/"/>
    <id>http://www.lixiaolin.me/2016/01/05/properties-coding/</id>
    <published>2016-01-05T08:20:53.000Z</published>
    <updated>2016-01-05T08:21:54.249Z</updated>
    <content type="html"><![CDATA[<p>首先知道乱码的原因，properties文件的默认编码是iso8859-1，所以我们往里面存中文，但是取出来的时候一般不是用ISO8859-1取的，所以乱码，那么只要编码和解码一致就不会乱码了。<br><a id="more"></a><br>1、直接在Java文件中修改</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream <span class="keyword">in</span>=<span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/proper2.properties"</span>);</span><br><span class="line">Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">pro.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="built_in">String</span> name=pro.getProperty(<span class="string">"name"</span>);</span><br><span class="line">response.getWriter().write(<span class="keyword">new</span> <span class="built_in">String</span>(name.getBytes(<span class="string">"iso8859-1"</span>),<span class="string">"utf-8"</span>));</span><br></pre></td></tr></table></figure>
<p>但是可以看到这样虽然有效，却比较耗费时间和资源，那么可以使用方法2</p>
<p>2、直接修改properties的编码<br>在myeclipse下打开 window-&gt;Perferences-&gt;General-&gt;ContentTypes  然后将编码从默认的iso8859-1改为utf-8即可<br>如果这样还没有用的话，还有一招，那就是在编辑properties文件的时候使用myeclipse自带的propertieseditor打开（默认就是这个），打开后选择左下角的properties，直接在编辑器里编辑就好<br>如下图<br><img src="http://img.blog.csdn.net/20150917204612184" alt="这里写图片描述"></p>
<p>然后我们点左下角的source 可以看到如下：<br><img src="http://img.blog.csdn.net/20150917204645573" alt="这里写图片描述"><br>此时的 哈哈  已经被转换过了，这也就是为什么我们改properties的编码改完后无效的原因，虽然你改了编码，但是你直接在source里面编辑输入中文的话，中文是存不进去的。<br>这样昨晚后就能输出中文了。</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">response</span>.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">InputStream <span class="keyword">in</span>=this.getServletContext().getResourceAsStream(<span class="string">"/proper2.properties"</span>);</span><br><span class="line">Properties pro=<span class="keyword">new</span> Properties();</span><br><span class="line">pro.load(<span class="keyword">in</span>);</span><br><span class="line"><span class="built_in">String</span> name=pro.getProperty(<span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">response</span>.getWriter().write(name);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先知道乱码的原因，properties文件的默认编码是iso8859-1，所以我们往里面存中文，但是取出来的时候一般不是用ISO8859-1取的，所以乱码，那么只要编码和解码一致就不会乱码了。<br>]]>
    
    </summary>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSP编码以及乱码解决总结]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/jsp-coding/"/>
    <id>http://www.lixiaolin.me/2016/01/05/jsp-coding/</id>
    <published>2016-01-05T08:19:31.000Z</published>
    <updated>2016-01-05T08:20:16.617Z</updated>
    <content type="html"><![CDATA[<p>首先，说说JSP/Servlet中的几个编码的作用：<br>1.&lt;%@pagepageEncoding=”UTF-8” %&gt;作用：</p>
<ul>
<li>告诉JSP编译器在将JSP文件编译成Servlet时使用的编码。通常，在JSP内部定义的字符串(直接在JSP中定义，而不是从浏览器提交的数据)出现乱码时，很多都是由于该参数设置错误引起的。<a id="more"></a>
例如，你的JSP文件是以GBK为编码保存的 (右击jsp–&gt;Properties –&gt; Text file encoding设置成与pageEncoding不一致时，就有乱码)，而在JSP中却指定pageEncoding=”UTF-8”，就会引起JSP内部定义的字符串为乱码。</li>
<li>当JSP中不指定contentType参数，也不使用response.setCharacterEncoding方法时，指定对服务器响应进行重新编码的编码<br>2.&lt;%@pagecontentType=”text/html;charset=GBK” %&gt;response.setCharacterEncoding(“UTF-8”)作用：</li>
<li>指定对服务器响应进行重新编码的编码,服务器在将数据发送到浏览器前，对数据进行重新编码。<ul>
<li>浏览器也是根据这个参数来对其接收到的数据进行解码，对其发送的请求参数进行编码(如果参数有：&lt;%=URLEncoder.encode(“测试”,”GBK”) %&gt;或javascript：encodeURI(“测试”)则以后者为准)，<br>自己可以在IE的菜单中选择：查看(V) –&gt; 编码(D)查看得知浏览器的编码(解码)和&lt;%@page contentType=”text/html;charset=GBK” %&gt;  response.setCharacterEncoding(“UTF-8”)设置的编码是一致的。<br>因此：只要响应结果不是乱码，则浏览器显示结果一定不会是乱码(服务器对响应编码和浏览器对响应解码的编码是一样的)。出现乱码的情况是：浏览器编码 —&gt; 服务器解码得到的结果是乱码 —&gt; 造成响应有乱码 –&gt; 浏览器显示乱码<br>3.<br>//<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">作用：</li>
</ul>
</li>
<li>控制浏览器的以何种编码显示网页的内容</li>
<li>与2中page指令设置的区别是，meta设置的是浏览器解释，page设置的是服务端解释<br>4.request.setCharacterEncoding(“charset”)作用：</li>
<li>设置对客户端请求参数进行解码所使用的编码.</li>
<li>只对两种请求参数提交方式有效:</li>
<li>POST表单提交</li>
<li>GET提交(url或GET表单提交), 此时要求配置<br>server.xml的<connector>标签的属性:useBodyEncodingForURI=”true”<br>5.request.getParameter(“param”)和request.getParameterValues(“param”)<br>所获取到的参数数据都是经过服务器解码后的数据</connector></li>
</ul>
<p>接着说下发送请求到返回响应整个编码解码过程：<br>1.浏览器对请求编码–&gt; 服务器(容器)对请求解码 —&gt; 服务器对响应编码 —&gt; 浏览器对响应解码<br>浏览器编码 —&gt; 容器解码<br>浏览器编码默认是使用response.setCharacterEncoding—contentType—pageEncoding的优先顺序指定的编码的，但当对某些参数使用&lt;%=URLEncoder.encode(“测试”,”GBK”) %&gt;或javascript：encodeURI(“测试”)来对参数编码时，会覆盖默认编码，即浏览器这些特定的参数编码以&lt;%=URLEncoder.encode(“测试”,”GBK”) %&gt;或javascript：encodeURI(“测试”)为准<br>注意：javascript的编码方式：encodeURI(..)和encodeURIComponent(..)是对其参数进行UTF-8编码的<br>2.浏览器最终显示响应结果出现乱码是因为在过程：<br>浏览器对请求编码 –&gt; 服务器(容器)对请求解码，出现乱码。<br>原因是：服务器对响应编码和浏览器对响应解码所使用的编码都是相同的，为response.setCharacterEncoding—contentType指定的编码，而浏览器对请求参数的编码 和 服务器对请求参数解码 所使用的编码如果不一致，就会造成乱码<br>3.对中文解码，无论使用什么解码方式都是中文。中文只有经过编码，再解码才会出现乱码的可能，如果起始编码和末尾解码所使用的编码一致，就不会出现乱码<br>4.浏览器编解码说明：<br>浏览器在接收或发送数据时，会对URL和参数会进行URL解码(接收)或编码(发送)，所使用的编码为：&lt;%@pagecontentType=”text/html;charset=GBK” %&gt;或response.setCharacterEncoding(“UTF-8”)指定的编码<br>5.服务器编解码说明：</p>
<ul>
<li>服务器发送数据时，按照response.setCharacterEncoding—contentType—pageEncoding的优先顺序，对要发送的数据进行编码。</li>
<li>服务器接收数据，要分三种情况。一种是浏览器直接用URL提交的数据，另外两种是用表单的GET和POST方式提交的数据<br>（1）表单中POST方式提交的情况：<br>可以通过request.setCharacterEncoding(charset)，来设置对浏览器提交的数据使用什么样的编码进行解码。如果不设置时，服务器默认使用ISO-8859-1来解码请求参数。如果页面的contentType=”GBK”, 此时要想得到正确的结果，则：<br>Stringname = newString(request.getParameter(“name”).getBytes(“ISO-8859-1”),”GBK”);<br>如果设置：request.setCharacterEncoding(“GBK”),则只需：String name = request .getParameter(“name”);<br>所以对于POST表单提交的数据，在获得数据的JSP页面中request.setCharacterEncoding要和生成提交该表单的JSP页面的response.setCharacterEncoding设置成相同的值。还有一种方法解决POST提交乱码问题：使用过滤器，在过滤器中设置request.setCharacterEncoding(charset)<br>（2）URL提交的数据和表单中GET方式提交的情况：<br>此时设置request.setCharacterEncoding参数是不行的，因为在Tomcat5.0中，默认情况下使用ISO-8859-1对URL提交的数据和表单中GET方式提交的数据进行解码，而不使用该参数对URL提交的数据和表单中GET方式提交的数据解码。要解决该问题，应该在Tomcat的配置文件server.xml的Connector标签中设置useBodyEncodingForURI或者URIEncoding属性，<br><em>useBodyEncodingForURI参数为true时表示用request.setCharacterEncoding参数对URL提交的数据和表单中GET方式提交的数据进行重新解码。
</em>URIEncoding参数指定对所有GET方式请求(包括URL提交的数据和表单中GET方式提交的数据)进行统一解码的编码<br>即处理get方式请求参数有四种情况：</li>
<li>不设置server.xml的Connector标签，此时服务器统一对get方式的请求参数进行ISO-8859-1解码，此时设置request.setCharacterEncoding(charset)是无效的</li>
<li>设置server.xml的Connector标签，令useBodyEncodingForURI=”true”，此时使用情况和post提交方式一致</li>
<li>设置server.xml的Connector标签，令URIEncoding=”charset”,此时服务器统一对get方式的请求参数进行charset解码</li>
<li>设置server.xml的Connector标签，令useBodyEncodingForURI=”true”URIEncoding=”charset”, 此时URIEncoding设置无效</li>
</ul>
<connectorport="8080" maxthreads="150" minsparethreads="25" maxsparethreads="75" enablelookups="false" redirectport="8443" acceptcount="100" debug="0" connectiontimeout="20000" disableuploadtimeout="true" usebodyencodingforuri="true" uriencoding="UTF-8">

<p>范例：URLDecoder.decode(..)是服务器端解码的，而encodeURI(..)是js在客户端编码的</p>
<ol>
<li>javascrip对于get方式的参数编码: Java代码:url=encodeURI(url);服务器端获取参数后解码: Java代码<br>Stringlinename = newString(request.getParameter(“name”).getBytes(“ISO-8859-1”),”UTF-8”);<br>说明：此时并没有对server.xml的<connector>配置useBodyEncodingForURI和URIEncoding属性<br>编码过程：浏览器编码(UTF-8)–&gt; 服务器解码(ISO-8859-1) –&gt; String.getBytes方法编码(ISO-8859-1)–&gt; 创建String解码(UTF-8)<br>2.javascript:url=encodeURI(encodeURI(url)); //用了2次encodeURI服务器端获取: Java代码<br>Stringlinename = request.getParameter(name); //java : 字符解码linename =java.net.URLDecoder.decode(linename , “UTF-8”);<br>浏览器编码(UTF-8) –&gt; 浏览器编码(UTF-8)–&gt; 服务器解码(ISO-8859-1) –&gt; URLDecoder解码(UTF-8)<br>3.jsp对于get方式的参数编码:url=”….”?sport=&lt;%=URLEncoder.encoder(“篮球”,”UTF-8”) %&gt;<br>服务器端获取参数后解码: Java代码<br>Stringlinename = newString(request.getParameter(“name”).getBytes(“ISO-8859-1”),”UTF-8”);<br>说明：此时并没有对server.xml的<connector>配置useBodyEncodingForURI和URIEncoding属性<br>编码过程：浏览器编码(UTF-8)–&gt; 服务器解码(ISO-8859-1) –&gt; String.getBytes方法编码(ISO-8859-1)–&gt; 创建String解码(UTF-8)</connector></connector></li>
</ol>
<p>对范例2的说明：<br>可能大家都觉得对中文进行两次UTF-8编码后，进行一次ISO-8859-1解码和一次UTF-8解码，为什么得到的不是乱码呢？<br>个人认为java提供的URLEncoder和URLdecoder内部是做了某些处理的，和通String.getBytes获取字节数组，再newString(bytes[], charset)编解码方式使不一样的。如java代码:<br>String str = “汉字test”;<br>            String str1 = URLEncoder.encode(str, “UTF-8”);<br>            String str2 = URLEncoder.encode(str, “ISO-8859-1”);<br>            String str3 = URLEncoder.encode(str, “UTF-8”);<br>            String str4 = URLEncoder.encode(str3, “ISO-8859-1”);<br>            //使用UTF-8编码  解码成功<br>            String str6 = URLDecoder.decode(str1, “UTF-8”);<br>            //使用ISO-8859-1编码  解码失败<br>            String str7 = URLDecoder.decode(str2, “ISO-8859-1”);<br>            //编码次数为两次，解码一次，解码失败<br>            String str8 = URLDecoder.decode(str4, “UTF-8”);<br>            //编码次数等于解码次数，且最终解码方式为字符串初始编码方式就能解码成功，<br>            //即使中间编码方式为ISO-8859-1<br>            String str9 = URLDecoder.decode(str8, “UTF-8”);<br>从执行结果分析，个人觉得URLEncoder和URLDecoder对ASCII内的字符进行编码, 无论URLEncoder.encode的charset参数是什么，<br>得到的编码结果都是一样的，无论URLDecoder.decode的charset参数是什么，得到的解码结果都一样，只要中文的起始编码charset和最后解码的chaset一致(这里都是UTF-8)，中间编码和解码次数对等(这里均为两次), 则得到的结果就不会乱码。</p>
</connectorport="8080">]]></content>
    <summary type="html">
    <![CDATA[<p>首先，说说JSP/Servlet中的几个编码的作用：<br>1.&lt;%@pagepageEncoding=”UTF-8” %&gt;作用：</p>
<ul>
<li>告诉JSP编译器在将JSP文件编译成Servlet时使用的编码。通常，在JSP内部定义的字符串(直接在JSP中定义，而不是从浏览器提交的数据)出现乱码时，很多都是由于该参数设置错误引起的。]]>
    
    </summary>
    
      <category term="JSP" scheme="http://www.lixiaolin.me/tags/JSP/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java String的经典问题(new String() ,String )]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/java-string-demo/"/>
    <id>http://www.lixiaolin.me/2016/01/05/java-string-demo/</id>
    <published>2016-01-05T08:17:56.000Z</published>
    <updated>2016-01-05T11:14:03.033Z</updated>
    <content type="html"><![CDATA[<p>先来看一个例子，代码如下：<br><a id="more"></a></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.public class Test &#123;</span><br><span class="line">    public static void main(<span class="keyword">String[] </span>args) &#123;</span><br><span class="line">        <span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">String </span><span class="keyword">str1 </span>= <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">String </span><span class="keyword">str2 </span>= new <span class="keyword">String("abc");</span><br><span class="line"></span>        System.out.println(<span class="keyword">str </span>== <span class="keyword">str1);</span><br><span class="line"></span>        System.out.println(<span class="keyword">str1 </span>== <span class="string">"abc"</span>)<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="keyword">str2 </span>== <span class="string">"abc"</span>)<span class="comment">;</span></span><br><span class="line">        System.out.println(<span class="keyword">str1 </span>== <span class="keyword">str2);</span><br><span class="line"></span>        System.out.println(<span class="keyword">str1.equals(str2));</span><br><span class="line"></span>        System.out.println(<span class="keyword">str1 </span>== <span class="keyword">str2.intern());</span><br><span class="line"></span>        System.out.println(<span class="keyword">str2 </span>== <span class="keyword">str2.intern());</span><br><span class="line"></span>        System.out.println(<span class="keyword">str1.hashCode() </span>== <span class="keyword">str2.hashCode());</span><br><span class="line"></span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您能对这8个输出结果直接判断出来，下面的分析就不用看了。但是我想还是有很多人对这个String对象这个问题只是表面的理解，下面就来分析一下Java语言String类和对象及其运行机制的问题。<br>    做个基础的说明，堆(heap)内存和栈(Stack)内存的问题。堆和栈的数据结构这里就不解释了。Java语言使用内存的时候，栈内存主要保存以下内容：基本数据类型和对象的引用，而堆内存存储对象，栈内存的速度要快于堆内存。总结成一句话就是：引用在栈而对象在堆。<br>    Java中的比较有两种，是==和equals()方法，equals()是Object类的方法，定义在Object类中的equals()方法是如下实现的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[java] view plaincopy</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> String类重写了equals()方法，改变了这些类型对象相等的原则，即判断对象是否相等依据的原则为判断二者的内容是否相等。<br>              了解以上内容后我们来说说String，String类的本质是字符数组char[]，其次String类是final的，是不可被继承的，这点可能被大多数人忽略，再次String是特殊的封装类型，使用String时可以直接赋值，也可以用new来创建对象，但是这二者的实现机制是不同的。还有一个String池的概念，Java运行时维护一个String池，池中的String对象不可重复，没有创建，有则作罢。String池不属于堆和栈，而是属于常量池。下面分析上方代码的真正含义<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[html] view plaincopy</span><br><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"abc"</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str1= </span><span class="string">"abc"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>  第一句的真正含义是在String池中创建一个对象”abc”，然后引用时str指向池中的对象”abc”。第二句执行时，因为”abc”已经存在于String池了，所以不再创建，则str==str1返回true就明白了。str1==”abc”肯定正确了，在String池中只有一个”abc”，而str和str1都指向池中的”abc”，就是这个道理。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[html] view plaincopy</span><br><span class="line"><span class="built_in">String</span> str2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p> 这个是Java SE的热点问题，众所周知，单独这句话创建了2个String对象，而基于上面两句，只在栈内存创建str2引用，在堆内存上创建一个String对象，内容是”abc”，而str2指向堆内存对象的首地址。    下面就是str2==”abc”的问题了，显然不对，”abc”是位于String池中的对象，而str2指向的是堆内存的String对象，==判断的是地址，肯定不等了。<br>          str1.equals(str2)，这个是对的，前面说过，String类的equals重写了Object类的equals()方法，实际就是判断内容是否相同了。<br>          下面说下intern()方法，在JavaDoc文档中，这样描述了intern()方法：返回字符串对象的规范化表示形式。怎么理解这句话？实际上过程是这样进行的：该方法现在String池中查找是否存在一个对象，存在了就返回String池中对象的引用。<br>           那么本例中String池存在”abc”，则调用intern()方法时返回的是池中”abc”对象引用，那么和str/str1都是等同的，和str2就不同了，因为str2指向的是堆内存。<br>            hashCode()方法是返回字符串内容的哈希码，既然内容相同，哈希码必然相同，那他们就相等了，这个容易理解。<br>                     再看下面的例子：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[java] view plaincopy</span><br><span class="line">  <span class="keyword">public</span> class Test &#123;</span><br><span class="line">.     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"abc"</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">         <span class="keyword">String</span> str1 = <span class="string">"a"</span>;</span><br><span class="line">         <span class="keyword">String</span> str2 = <span class="string">"bc"</span>;</span><br><span class="line">         <span class="keyword">String</span> combo = str1 + str2;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="built_in">str</span> == combo);</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="built_in">str</span> == combo.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子用来说明用+连接字符串时，实际上是在堆内容创建对象，那么combo指向的是堆内存存储”abc”字符串的空间首地址，显然str==combo是错误的，而str==combo.intern()是正确的，在String池中也存在”abc”，那就直接返回了，而str也是指向String池中的”abc”对象的。此例说明任何重新修改String都是重新分配内存空间，这就使得String对象之间互不干扰。也就是String中的内容一旦生成不可改变，直至生成新的对象。</p>
<p>  同时问题也来了，使用+连接字符串每次都生成新的对象，而且是在堆内存上进行，而堆内存速度比较慢(相对而言)，那么再大量连接字符串时直接+是不可取的，当然需要一种效率高的方法。Java提供的StringBuffer和StringBuilder就是解决这个问题的。区别是前者是线程安全的而后者是非线程安全的，StringBuilder在JDK1.5之后才有。不保证安全的StringBuilder有比StringBuffer更高的效率。<br>               自JDK1.5之后，Java虚拟机执行字符串的+操作时，内部实现也是StringBuilder，之前采用StringBuffer实现。<br>    欢迎交流，希望对使用者有用。</p>
<p>原文地址：<a href="http://sarin.iteye.com/blog/603684" target="_blank" rel="external">http://sarin.iteye.com/blog/603684</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先来看一个例子，代码如下：<br>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[myeclipse new 后面的菜单设置]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/myeclipse-setting/"/>
    <id>http://www.lixiaolin.me/2016/01/05/myeclipse-setting/</id>
    <published>2016-01-05T08:16:21.000Z</published>
    <updated>2016-01-05T08:17:07.614Z</updated>
    <content type="html"><![CDATA[<p>有时候我们在使用myeclipse新建文件的时候，发现new中找不到自己想要的选项，还得点other去找，可以这样设置一下：<br><a id="more"></a><br>window -&gt; Customize Perspective -&gt; menu Visibility -&gt; file -&gt; new  然后选择自己想要的就好了<br>如图</p>
<p><img src="http://img.blog.csdn.net/20150919171429630" alt="这里写图片描述"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候我们在使用myeclipse新建文件的时候，发现new中找不到自己想要的选项，还得点other去找，可以这样设置一下：<br>]]>
    
    </summary>
    
      <category term="Myeclipse" scheme="http://www.lixiaolin.me/tags/Myeclipse/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自建连接池异常]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/connection-pool-exception/"/>
    <id>http://www.lixiaolin.me/2016/01/05/connection-pool-exception/</id>
    <published>2016-01-05T08:14:35.000Z</published>
    <updated>2016-01-05T08:15:38.884Z</updated>
    <content type="html"><![CDATA[<h1 id="u81EA_u5EFA_u8FDE_u63A5_u6C60_u5F02_u5E38_24Proxy0_cannot_be_cast_to_java-sql-Connection"><a href="#u81EA_u5EFA_u8FDE_u63A5_u6C60_u5F02_u5E38_24Proxy0_cannot_be_cast_to_java-sql-Connection" class="headerlink" title="自建连接池异常$Proxy0 cannot be cast to java.sql.Connection"></a>自建连接池异常$Proxy0 cannot be cast to java.sql.Connection</h1><p>今天在网上看到一个连接池的例子，于是按照所说的自己写了一遍，其构思比较巧妙，使用代理的方法在连接关闭的时候将连接送回连接池中，<br><a id="more"></a>主要代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 使用代理获取连接，确保释放（close）连接后，连接能被送回到连接池中</span><br><span class="line">  public <span class="type">Connection</span> getConnection() throws <span class="type">SQLException</span> &#123;</span><br><span class="line">    // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub</span><br><span class="line">    <span class="keyword">if</span>(listConnections.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      final <span class="type">Connection</span> conn=listConnections.removeFirst();</span><br><span class="line">      <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"从连接池释放了一个连接"</span>);</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">Connection</span>)<span class="type">Proxy</span>.newProxyInstance(<span class="type">JdbcPool</span>.class.getClassLoader(),conn.getClass().getInterfaces(), new <span class="type">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">        public <span class="type">Object</span> invoke(<span class="type">Object</span> proxy, <span class="type">Method</span> <span class="keyword">method</span>, <span class="type">Object</span>[] args)</span><br><span class="line">            throws <span class="type">Throwable</span> &#123;</span><br><span class="line">          // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub</span><br><span class="line">          <span class="keyword">if</span>(!<span class="keyword">method</span>.getName().equals(<span class="string">"close"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">method</span>.invoke(conn, args);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            //将关闭的连接送回连接池</span><br><span class="line">            listConnections.add(conn);</span><br><span class="line">            <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"连接被送回连接池"</span>);</span><br><span class="line">            <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"当前连接池大小为 "</span>+listConnections.size());</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      throw new <span class="type">RuntimeException</span>(<span class="string">"数据库正忙!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>但是测试的时候却抛异常<br>ClassCastException :  $Proxy0 cannot be cast to java.sql.Connection<br>后来网上查了些资料，发现是在获取代理的时候由于数据库驱动不同造成的。<br>应该改成<br><code>return (Connection)Proxy.newProxyInstance(JdbcPool.class.getClassLoader(),new Class[]{Connection.class}, new InvocationHandler() {...}</code><br>可以看到二者的区别是 一个使用了conn.getClass.getInterfaces()  另一个使用了new Class[]{Connection.class}  那么为什么会有这样的差别呢？<br>原来是这样的：<br>conn.getClass.getInterfaces()的结果与你的数据库驱动有关，驱动不同，其结果也就不同。比如你用mysql的驱动可能这样做可以，但是你在oracle下就可能出问题。conn.getClassInterfaces()返回的是一个Class数组，它的第一个元素必须是一个Connection才能将创建的代理转化为Connection，所以用conn.getClass.getInterfaces()不行，具有太多的不稳定性。那么，既然需要的是一个Connection来转化，那么我们直接给一个Connection就好，这也是为什么我们使用new Class[]{Connection.class}有用的原因了。<br>另外还有一个有趣的现象，看下面这段代码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>[] interfaces = conn.getClass().getInterfaces();</span><br><span class="line">       <span class="keyword">if</span>(interfaces==<span class="keyword">null</span>||interfaces.length==<span class="number">0</span>)&#123;</span><br><span class="line">         System.out.<span class="keyword">println</span>(<span class="string">"空的"</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>我测试发现输出结果是 空的 ，看来获取到的interfaces数组是一个空的数组。如果有朋友一定要用conn.getClass().getInterfaces()这种方法，那么该怎么办呢？可以这么做：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span>[] <span class="title">interfaces</span> = <span class="title">conn</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>();</span></span><br><span class="line">       <span class="keyword">if</span>(interfaces==<span class="literal">null</span>||interfaces.length==<span class="number">0</span>)&#123;</span><br><span class="line">         interfaces = <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[1];</span></span><br><span class="line">         interfaces[<span class="number">0</span>] = Connection.class;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这样就好了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u81EA_u5EFA_u8FDE_u63A5_u6C60_u5F02_u5E38_24Proxy0_cannot_be_cast_to_java-sql-Connection"><a href="#u81EA_u5EFA_u8FDE_u63A5_u6C60_u5F02_u5E38_24Proxy0_cannot_be_cast_to_java-sql-Connection" class="headerlink" title="自建连接池异常$Proxy0 cannot be cast to java.sql.Connection"></a>自建连接池异常$Proxy0 cannot be cast to java.sql.Connection</h1><p>今天在网上看到一个连接池的例子，于是按照所说的自己写了一遍，其构思比较巧妙，使用代理的方法在连接关闭的时候将连接送回连接池中，<br>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="MYSQL" scheme="http://www.lixiaolin.me/tags/MYSQL/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[algorithm-binary-tree-fml-order]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/algorithm-binary-tree-fml-order/"/>
    <id>http://www.lixiaolin.me/2016/01/05/algorithm-binary-tree-fml-order/</id>
    <published>2016-01-05T08:12:45.000Z</published>
    <updated>2016-01-05T08:13:47.413Z</updated>
    <content type="html"><![CDATA[<p>二叉树是数据结构里经常使用的一种数据结构，需要注意其和树的区别（二叉树的一个节点最多只能有2个子树，而树没这个限制），还有完全二叉树和满二叉树。<br><a id="more"></a><br>创建如下图的一颗二叉树：</p>
<p><img src="http://img.blog.csdn.net/20151014224811773" alt="这里写图片描述"></p>
<p>####<strong>一、创建二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node root=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root=<span class="keyword">new</span> Node(<span class="string">"A"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 创建一颗二叉树</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinaryTree</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    Node nodeB=<span class="keyword">new</span> Node(<span class="string">"B"</span>);</span><br><span class="line">    Node nodeC=<span class="keyword">new</span> Node(<span class="string">"C"</span>);</span><br><span class="line">    Node nodeD=<span class="keyword">new</span> Node(<span class="string">"D"</span>);</span><br><span class="line">    Node nodeE=<span class="keyword">new</span> Node(<span class="string">"E"</span>);</span><br><span class="line">    Node nodeF=<span class="keyword">new</span> Node(<span class="string">"F"</span>);</span><br><span class="line">    Node nodeG=<span class="keyword">new</span> Node(<span class="string">"G"</span>);</span><br><span class="line">    Node nodeH=<span class="keyword">new</span> Node(<span class="string">"H"</span>);</span><br><span class="line">    Node nodeI=<span class="keyword">new</span> Node(<span class="string">"I"</span>);</span><br><span class="line">    Node nodeM=<span class="keyword">new</span> Node(<span class="string">"M"</span>);</span><br><span class="line">    Node nodeN=<span class="keyword">new</span> Node(<span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line">    root.leftChild=nodeB;</span><br><span class="line">    root.rightChild=nodeC;</span><br><span class="line">    nodeB.leftChild=nodeD;</span><br><span class="line">    nodeB.rightChild=nodeE;</span><br><span class="line">    nodeD.leftChild=nodeH;</span><br><span class="line">    nodeC.leftChild=nodeF;</span><br><span class="line">    nodeC.rightChild=nodeG;</span><br><span class="line">    nodeE.rightChild=nodeI;</span><br><span class="line">    nodeI.leftChild=nodeM;</span><br><span class="line">    nodeI.rightChild=nodeN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">   * 二叉树结点</span><br><span class="line">   * <span class="doctag">@author</span>: lixiaolin</span><br><span class="line">   * <span class="doctag">@CreateDate</span>: 2015-10-14 下午10:18:35</span><br><span class="line">   * <span class="doctag">@version</span>: 1.0</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="keyword">private</span> Node leftChild;</span><br><span class="line">    <span class="keyword">private</span> Node rightChild;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data=data;</span><br><span class="line">      <span class="keyword">this</span>.leftChild=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.rightChild=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>####<strong>二、遍历二叉树</strong><br>遍历是二叉树经常使用的操作。<br>常用的遍历方式有先序、中序、后序，这个是针对跟节点的访问顺序而言的。<br>下面先给出递归遍历二叉树的方法</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * 先序递归遍历</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visted(root);</span><br><span class="line">    preOrder(root.leftChild);</span><br><span class="line">    preOrder(root.rightChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 中序递归遍历</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root.leftChild);</span><br><span class="line">    visted(root);</span><br><span class="line">    inOrder(root.rightChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 后序递归遍历</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root.leftChild);</span><br><span class="line">    postOrder(root.rightChild);</span><br><span class="line">    visted(root);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>####<strong>三、非递归遍历</strong><br>先序遍历和中序遍历的思路差不多，都在先遍历完所有的左子树，将之存储到栈中，利用栈的先进后出的特点，碰到有右子树的节点，先将其输出，然后加入栈中。<br>后序的思路不一样。要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 非递归先序遍历</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void noRecPreOrder(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span>=root;</span><br><span class="line">    Stack<span class="tag">&lt;Node&gt;</span> <span class="variable">stack=</span>new Stack<span class="tag">&lt;Node&gt;</span>();</span><br><span class="line">    while(<span class="keyword">node</span><span class="identifier"></span><span class="title">!=null</span>)&#123;</span><br><span class="line">      visted(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">      stack</span>.push(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">      node</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!stack.empty())&#123;</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=stack</span>.pop();</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=node</span>.rightChild;</span><br><span class="line">      while(<span class="keyword">node</span><span class="identifier"></span><span class="title">!=null</span>)&#123;</span><br><span class="line">        visted(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">        stack</span>.push(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">        node</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 非递归实现中序遍历</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void noRecInOrder(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack<span class="tag">&lt;Node&gt;</span> <span class="variable">stack=</span>new Stack<span class="tag">&lt;Node&gt;</span> ();</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span>=root;</span><br><span class="line">    while(<span class="keyword">node</span><span class="identifier"></span><span class="title">!=null</span>)&#123;</span><br><span class="line">      stack.push(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">      node</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(!stack.empty())&#123;</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=stack</span>.pop();</span><br><span class="line">      visted(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">      node</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>;</span><br><span class="line">      while(<span class="keyword">node</span><span class="identifier"></span><span class="title">!=null</span>)&#123;</span><br><span class="line">        stack.push(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">        node</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 非递归后序遍历</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void noRecPostOrder(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack<span class="tag">&lt;Node&gt;</span> <span class="variable">stack=</span>new Stack<span class="tag">&lt;Node&gt;</span>();</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span>=root;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">preVisted</span>=null;</span><br><span class="line">    stack.push(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">    while</span>(!stack.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=stack</span>.peek();</span><br><span class="line">      if((<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>==null&amp;&amp;<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>==null)||(preVisted!=null&amp;&amp;(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>==preVisted||<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>==preVisted)))&#123;</span><br><span class="line">        <span class="keyword">node</span><span class="identifier"></span><span class="title">=stack</span>.pop();</span><br><span class="line">        visted(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">        preVisted</span>=<span class="keyword">node</span><span class="identifier"></span><span class="title">;</span><br><span class="line">      &#125;else</span>&#123;</span><br><span class="line">        if(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>!=null)&#123;</span><br><span class="line">          stack.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        if(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>!=null)&#123;</span><br><span class="line">          stack.push(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>二叉树是数据结构里经常使用的一种数据结构，需要注意其和树的区别（二叉树的一个节点最多只能有2个子树，而树没这个限制），还有完全二叉树和满二叉树。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.lixiaolin.me/tags/Algorithm/"/>
    
      <category term="BinaryTree" scheme="http://www.lixiaolin.me/tags/BinaryTree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[去除字符串重复部分]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/algorithm-remove-same-string/"/>
    <id>http://www.lixiaolin.me/2016/01/05/algorithm-remove-same-string/</id>
    <published>2016-01-05T08:10:28.000Z</published>
    <updated>2016-01-05T08:11:35.898Z</updated>
    <content type="html"><![CDATA[<p>昨天笔试有这么一个问题，<strong>去除一个字符数组的重复部分，不能开辟额外的空间。</strong><br>思路大概如下：<br>利用字符串结束符 ‘\0’,和一个额外的下标index，从而实现原来字符数组的复用。<br><a id="more"></a><br>1、对数组遍历，如果不为’\0’，做第二步<br>2、将当前元素的值赋给下标为index的数组，index往后移动一位<br>3、对当前元素之后的所有元素进行遍历，如果碰到和当前元素相同的，将其置为 ‘\0’<br>4、对数组遍历结束，index对应的数组值置 ‘\0’<br>5、这时候就得到了去重的字符数组，结束位置为index</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove3</span><span class="params">(<span class="keyword">char</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == null || <span class="built_in">array</span>.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">array</span>.length;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">array</span>[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="built_in">array</span>[index++] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">array</span>[j] == <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">            <span class="built_in">array</span>[j] = <span class="string">'\0'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[index] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">array</span>[k] != <span class="string">'\0'</span>) &#123;</span><br><span class="line">      sb.append(<span class="built_in">array</span>[k++]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>测试用例：<br>1、连续重复的：aabbccdd<br>2、非连续重复：abbjkjsab</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天笔试有这么一个问题，<strong>去除一个字符数组的重复部分，不能开辟额外的空间。</strong><br>思路大概如下：<br>利用字符串结束符 ‘\0’,和一个额外的下标index，从而实现原来字符数组的复用。<br>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://www.lixiaolin.me/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate与Mysql 5.5创建表出错--table doesn't exist]]></title>
    <link href="http://www.lixiaolin.me/2016/01/05/hibernate-mysql-create-table/"/>
    <id>http://www.lixiaolin.me/2016/01/05/hibernate-mysql-create-table/</id>
    <published>2016-01-05T08:05:14.000Z</published>
    <updated>2016-01-05T08:07:06.765Z</updated>
    <content type="html"><![CDATA[<p>最近在学习hibernate，利用其自动创建表时老是出错，<br><a id="more"></a><br>出错信息如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR: HHH000388: Unsuccessful: <span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> NEWS (<span class="keyword">ID</span> <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment, TITLE <span class="built_in">varchar</span>(<span class="number">255</span>), AUTHOR <span class="built_in">varchar</span>(<span class="number">255</span>), <span class="built_in">DATE</span> <span class="built_in">date</span>, primary <span class="keyword">key</span> (<span class="keyword">ID</span>)) <span class="keyword">type</span>=<span class="keyword">InnoDB</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">38</span> org.hibernate.tool.hbm2ddl.SchemaUpdate <span class="keyword">execute</span></span><br><span class="line"><span class="keyword">ERROR</span>: You have an <span class="keyword">error</span> <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax;</span> <span class="operator"><span class="keyword">check</span> the <span class="keyword">manual</span> that corresponds <span class="keyword">to</span> your MySQL <span class="keyword">server</span> <span class="keyword">version</span> <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> <span class="keyword">use</span> near <span class="string">'type=InnoDB'</span> <span class="keyword">at</span> line <span class="number">7</span></span><br><span class="line"><span class="number">2015</span>-<span class="number">12</span>-<span class="number">24</span> <span class="number">13</span>:<span class="number">50</span>:<span class="number">38</span> org.hibernate.tool.hbm2ddl.SchemaUpdate <span class="keyword">execute</span></span></span><br></pre></td></tr></table></figure>
<p>经过分析，可以看出提示在type=InnoDB这里出错，将hibernate自动生成的建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> NEWS (<span class="keyword">ID</span> <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment, TITLE <span class="built_in">varchar</span>(<span class="number">255</span>), AUTHOR <span class="built_in">varchar</span>(<span class="number">255</span>), <span class="built_in">DATE</span> <span class="built_in">date</span>, primary <span class="keyword">key</span> (<span class="keyword">ID</span>)) <span class="keyword">type</span>=<span class="keyword">InnoDB</span></span></span><br></pre></td></tr></table></figure>
<p>在mysql下运行同样报错，经查资料发现是这么一回事：<br> 在mysql 5.0版本以后不支持 type=InnoDB 关键字，需要使用 engine=InnoDB<br>解决放下如下：<br>在hinernate.cfg.xml配置文件中修改本地方言即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--原来用的是MySQLInnoDBDialect，改为MySQL5Dialect即可--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLInnoDBDialect&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习hibernate，利用其自动创建表时老是出错，<br>]]>
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.lixiaolin.me/tags/Hibernate/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Oracle存储过程和job在项目中的应用]]></title>
    <link href="http://www.lixiaolin.me/2016/01/03/oracle-procedure-job/"/>
    <id>http://www.lixiaolin.me/2016/01/03/oracle-procedure-job/</id>
    <published>2016-01-03T14:55:38.000Z</published>
    <updated>2016-01-04T13:10:12.296Z</updated>
    <content type="html"><![CDATA[<p>最近在实习公司的项目开发中有遇到这么一个需求：在做一个电价管理系统中，有新增电价这么一个功能，新增电价默认不生效，用户可以手动选择生效的时间，到了时间电价就自动变成生效。<a id="more"></a><br>如下图所示<br><img src="http://img.blog.csdn.net/20150817151002706" alt="这里写图片描述"><br>在界面中是这样的<br><img src="http://img.blog.csdn.net/20150817151033155" alt="这里写图片描述"><br>对于这个需求我们可以利用存储过程和job来实现。<br>新建一个存储过程对电价生效标志进行更新，然后在job中每天定时执行这个存储过程<br>sql语句如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--create procedure</span></span><br><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> p_carstatus <span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">update</span> e_price <span class="keyword">e</span> <span class="keyword">set</span> <span class="keyword">e</span>.release_flag=<span class="string">'是'</span> <span class="keyword">where</span> <span class="keyword">sysdate</span> &gt; <span class="keyword">e</span>.release_date;</span></span><br><span class="line"><span class="operator"><span class="keyword">COMMIT</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">end</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--create job</span></span><br><span class="line"><span class="operator"><span class="keyword">declare</span></span><br><span class="line">jobno   <span class="built_in">number</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">begin</span></span><br><span class="line">dbms_job.submit(:jobno,<span class="string">'p_carstatus;'</span>,<span class="keyword">sysdate</span>,<span class="string">'trunc(sysdate)+1'</span>);</span><span class="comment">--每天凌晨，注意不要漏掉 jobno前面的:</span></span><br><span class="line"><span class="operator"><span class="keyword">commit</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">end</span>;</span></span><br></pre></td></tr></table></figure>
<p>这样就能实现定时对电价生效标志进行更新了，以上只是一个例子，存储过程和job结合使用的例子还有很多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在实习公司的项目开发中有遇到这么一个需求：在做一个电价管理系统中，有新增电价这么一个功能，新增电价默认不生效，用户可以手动选择生效的时间，到了时间电价就自动变成生效。]]>
    
    </summary>
    
      <category term="ORACLE" scheme="http://www.lixiaolin.me/tags/ORACLE/"/>
    
      <category term="PROCEDURE" scheme="http://www.lixiaolin.me/tags/PROCEDURE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非递归实现二叉树的层次遍历]]></title>
    <link href="http://www.lixiaolin.me/2016/01/03/algorithm-binary-tree-levelorder/"/>
    <id>http://www.lixiaolin.me/2016/01/03/algorithm-binary-tree-levelorder/</id>
    <published>2016-01-03T14:51:39.000Z</published>
    <updated>2016-01-03T15:00:43.715Z</updated>
    <content type="html"><![CDATA[<p>非递归的层次遍历其实很简单。利用了队列先进先出的特点。<br>先将根节点入队。如果队列不为空，那么获得队首元素，对其访问。如果它的左子树不为空，那么加入队列，如果它的右子树不为空，那么加入队列。<br><a id="more"></a></p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 层次遍历</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void levelOrder(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue<span class="tag">&lt;Node&gt;</span> <span class="variable">queue=</span>new LinkedList<span class="tag">&lt;Node&gt;</span>();</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span>=root;</span><br><span class="line">    queue.add(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">    while</span>(!queue.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=queue</span>.poll();</span><br><span class="line">      visted(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">      if</span>(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>!=null)&#123;</span><br><span class="line">        queue.add(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      if(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>!=null)&#123;</span><br><span class="line">        queue.add(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>非递归的层次遍历其实很简单。利用了队列先进先出的特点。<br>先将根节点入队。如果队列不为空，那么获得队首元素，对其访问。如果它的左子树不为空，那么加入队列，如果它的右子树不为空，那么加入队列。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.lixiaolin.me/tags/Algorithm/"/>
    
      <category term="Binary-Tree" scheme="http://www.lixiaolin.me/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的常用操作]]></title>
    <link href="http://www.lixiaolin.me/2016/01/03/algorithm-binary-tree/"/>
    <id>http://www.lixiaolin.me/2016/01/03/algorithm-binary-tree/</id>
    <published>2016-01-03T14:49:54.000Z</published>
    <updated>2016-01-04T13:20:51.181Z</updated>
    <content type="html"><![CDATA[<p>二叉树就是每个结点最多有两个子树的树形存储结构。<br><a id="more"></a></p>
<h2 id="u4E00_u3001_u6C42_u4E8C_u53C9_u6811_u9AD8_u5EA6"><a href="#u4E00_u3001_u6C42_u4E8C_u53C9_u6811_u9AD8_u5EA6" class="headerlink" title="一、求二叉树高度"></a><strong>一、求二叉树高度</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * 求二叉树高度</span><br><span class="line">   * @param root</span><br><span class="line">   * @return</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=getHeight(root.leftChild);</span><br><span class="line">    <span class="keyword">int</span> r=getHeight(root.rightChild);</span><br><span class="line">    <span class="keyword">return</span> l&gt;r?l+<span class="number">1</span>:r+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4E8C_u3001_u6C42_u4E8C_u53C9_u6811_u7ED3_u70B9_u603B_u6570*"><a href="#u4E8C_u3001_u6C42_u4E8C_u53C9_u6811_u7ED3_u70B9_u603B_u6570*" class="headerlink" title="二、求二叉树结点总数*"></a><strong>二、求二叉树结点总数*</strong></h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * 求二叉树结点总数</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   * <span class="doctag">@return</span></span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+getSize(root.leftChild)+getSize(root.rightChild);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4E09_u3001_u9012_u5F52_u4EA4_u6362_u5DE6_u53F3_u5B50_u6811*"><a href="#u4E09_u3001_u9012_u5F52_u4EA4_u6362_u5DE6_u53F3_u5B50_u6811*" class="headerlink" title="三、递归交换左右子树*"></a><strong>三、递归交换左右子树*</strong></h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 交换左右子树</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void swapLeftAndRight(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">temp</span>=new <span class="keyword">Node</span><span class="identifier"></span><span class="title">();</span><br><span class="line">    temp</span>=root.leftChild;</span><br><span class="line">    root.<span class="variable">leftChild=</span>root.rightChild;</span><br><span class="line">    root.<span class="variable">rightChild=</span>temp;</span><br><span class="line">    swapLeftAndRight(root.leftChild);</span><br><span class="line">    swapLeftAndRight(root.rightChild);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u56DB_u3001_u975E_u9012_u5F52_u4EA4_u6362_u5DE6_u53F3_u5B50_u6811*"><a href="#u56DB_u3001_u975E_u9012_u5F52_u4EA4_u6362_u5DE6_u53F3_u5B50_u6811*" class="headerlink" title="四、非递归交换左右子树*"></a><strong>四、非递归交换左右子树*</strong></h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 非递归交换左右子树</span><br><span class="line">   * @param root</span><br><span class="line">   */</span><br><span class="line">  public void swapLeftAndRightNoRec(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">root</span>)&#123;</span><br><span class="line">    if(<span class="variable">root=</span>=null)&#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">node</span>=root;</span><br><span class="line">    Queue<span class="tag">&lt;Node&gt;</span> <span class="variable">queue=</span>new LinkedList<span class="tag">&lt;Node&gt;</span>();</span><br><span class="line">    queue.add(<span class="keyword">node</span><span class="identifier"></span><span class="title">);</span><br><span class="line">    while</span>(!queue.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">node</span><span class="identifier"></span><span class="title">=queue</span>.poll();</span><br><span class="line">      <span class="keyword">Node</span><span class="identifier"> </span><span class="title">temp</span>=new <span class="keyword">Node</span><span class="identifier"></span><span class="title">();</span><br><span class="line">      temp</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>;</span><br><span class="line">      <span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>=<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>;</span><br><span class="line">      <span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>=temp;</span><br><span class="line">      if(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>!=null)&#123;</span><br><span class="line">        queue.add(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">leftChild</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      if(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>!=null)&#123;</span><br><span class="line">        queue.add(<span class="keyword">node</span>.<span class="identifier"></span><span class="title">rightChild</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4E94_u3001_u5728_u4E8C_u53C9_u6811_u4E2D_u67E5_u627E_u67D0_u4E2A_u8282_u70B9"><a href="#u4E94_u3001_u5728_u4E8C_u53C9_u6811_u4E2D_u67E5_u627E_u67D0_u4E2A_u8282_u70B9" class="headerlink" title="五、在二叉树中查找某个节点"></a><strong>五、在二叉树中查找某个节点</strong></h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * 递归查找二叉树中是否存在某个节点</span><br><span class="line">   * <span class="doctag">@param</span> root</span><br><span class="line">   * <span class="doctag">@param</span> cNode</span><br><span class="line">   * <span class="doctag">@return</span></span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">checkNode</span><span class="params">(Node root,Node cNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span><span class="params">(root==cNode)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> existsFlag=<span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(root.leftChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        existsFlag=checkNode(root.leftChild, cNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!existsFlag&amp;&amp;root.rightChild!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        existsFlag=checkNode(root.rightChild, cNode);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> existsFlag;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u516D_u3001_u67E5_u627E_u4E24_u4E2A_u7ED3_u70B9_u7684_u6700_u8FD1_u7236_u8282_u70B9"><a href="#u516D_u3001_u67E5_u627E_u4E24_u4E2A_u7ED3_u70B9_u7684_u6700_u8FD1_u7236_u8282_u70B9" class="headerlink" title="六、查找两个结点的最近父节点"></a><strong>六、查找两个结点的最近父节点</strong></h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">Node <span class="title">getNearsetFarther</span><span class="params">(Node root,Node node1,Node node2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果node2的node1的子树中</span></span><br><span class="line">    <span class="keyword">if</span>(checkNode(node1, node2))&#123;</span><br><span class="line">      <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果node1在node2的子树中</span></span><br><span class="line">    <span class="keyword">if</span>(checkNode(node2, node1))&#123;</span><br><span class="line">      <span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> oneInLeft,oneInRight,twoInLeft,twoInRight;</span><br><span class="line">    oneInLeft=checkNode(root.leftChild, node1);</span><br><span class="line">    oneInRight=checkNode(root.rightChild, node1);</span><br><span class="line">    twoInLeft=checkNode(root.leftChild,node2);</span><br><span class="line">    twoInRight=checkNode(root.rightChild, node2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node1和node2不在同一边</span></span><br><span class="line">    <span class="keyword">if</span>((oneInLeft&amp;&amp;twoInRight)||(oneInRight&amp;&amp;oneInLeft))&#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//node1和node2都在左边</span></span><br><span class="line">    <span class="keyword">if</span>(oneInLeft&amp;&amp;twoInLeft)&#123;</span><br><span class="line">      <span class="function"><span class="keyword">return</span> <span class="title">getNearsetFarther</span><span class="params">(root.leftChild, node1, node2)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//node1和node2都在右边</span></span><br><span class="line">    <span class="keyword">if</span>(oneInRight&amp;&amp;twoInRight)&#123;</span><br><span class="line">      <span class="function"><span class="keyword">return</span> <span class="title">getNearsetFarther</span><span class="params">(root.rightChild, node1, node2)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>二叉树就是每个结点最多有两个子树的树形存储结构。<br>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.lixiaolin.me/tags/Algorithm/"/>
    
      <category term="Binary-Tree" scheme="http://www.lixiaolin.me/tags/Binary-Tree/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现超大整数（超过long长度范围）的加法运算]]></title>
    <link href="http://www.lixiaolin.me/2016/01/03/skill-biglong-int/"/>
    <id>http://www.lixiaolin.me/2016/01/03/skill-biglong-int/</id>
    <published>2016-01-03T14:48:22.000Z</published>
    <updated>2016-01-03T14:59:57.650Z</updated>
    <content type="html"><![CDATA[<p>昨天笔试，遇到这么一个问题：如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）。<br>其实这个问题很好解决，超大整数可以直接使用String来存储。对于两个String存储的超大整数的相加，先比较二者长度，在短的那个前面补0，使两个String一样长。<br><a id="more"></a><br>然后从尾部开始，挨个取数，相加并进位即可。代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">String</span> numAdd(<span class="type">String</span> a,<span class="type">String</span> b)&#123;</span><br><span class="line">    <span class="type">String</span> str=<span class="string">""</span>;</span><br><span class="line">    <span class="type">int</span> lenA=a.length();</span><br><span class="line">    <span class="type">int</span> lenB=b.length();</span><br><span class="line">    <span class="type">int</span> maxLen=lenA&gt;lenB?lenA:lenB;</span><br><span class="line">    <span class="type">int</span> minLen=lenA&lt;lenB?lenA:lenB;</span><br><span class="line">    <span class="type">StringBuilder</span> sb=new <span class="type">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxLen-minLen;i++)&#123;</span><br><span class="line">      sb.append(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lenA==minLen)&#123;</span><br><span class="line">      a=sb.append(a).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      b=sb.append(b).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb=new <span class="type">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> tempA,tempB,<span class="literal">result</span>;</span><br><span class="line">    <span class="type">int</span> sc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=maxLen-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      tempA=<span class="type">Integer</span>.valueOf(a.charAt(i)+<span class="string">""</span>);</span><br><span class="line">      tempB=<span class="type">Integer</span>.valueOf(b.charAt(i)+<span class="string">""</span>);</span><br><span class="line">      <span class="literal">result</span>=tempA+tempB+sc;</span><br><span class="line">      sc=<span class="literal">result</span>/<span class="number">10</span>;</span><br><span class="line">      <span class="literal">result</span>=<span class="literal">result</span>%<span class="number">10</span>;</span><br><span class="line">      sb.append(<span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sc==<span class="number">1</span>)&#123;</span><br><span class="line">      sb.append(sb);</span><br><span class="line">    &#125;</span><br><span class="line">    str=sb.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天笔试，遇到这么一个问题：如果系统要使用超大整数（超过long长度范围），请你设计一个数据结构来存储这种超大型数字以及设计一种算法来实现超大整数加法运算）。<br>其实这个问题很好解决，超大整数可以直接使用String来存储。对于两个String存储的超大整数的相加，先比较二者长度，在短的那个前面补0，使两个String一样长。<br>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://www.lixiaolin.me/tags/JAVA/"/>
    
      <category term="SKILL" scheme="http://www.lixiaolin.me/tags/SKILL/"/>
    
  </entry>
  
</feed>
